# This is a sample build configuration for Docker.
# Check our guides at https://confluence.atlassian.com/x/O1toN for more examples.
# Only use spaces to indent your .yml configuration.
# -----
# You can specify a custom docker image from Docker Hub as your build environment.
image: atlassian/default-image:2


definitions:
  services:
    docker:
      memory: 3072
  steps:
    - step: &build
        name: Build
        services:
          - docker
        caches:
          - docker
        script: # Modify the commands below to build your repository.
          # PROJECT SPECIFIC VARIABLES
          # (none)
          # We need to supply a good .env file that will work for
          # a dev environment deployment with minimal fuss
          - export ENV_FILE='files/.env'
          - cp files/.env.example $ENV_FILE
          # list of dev environment values we need to provide to .env file.
          # These will be supplied by variables from bitbucket
          - export VARLIST=$VARIABLE_SUBSTITUTION_LIST
          - export DB_PASSWORD=$DEV_DB_PASSWORD
          # overwrite values in file
          - for VARNAME in $VARLIST;
            do value=${!VARNAME}
            && echo "$VARNAME is $value"
            && cat $ENV_FILE | sed -E
            "s/^${VARNAME}=(.*)$/${VARNAME}=${value}/g"
            > $ENV_FILE.temp
            && mv $ENV_FILE.temp $ENV_FILE; done
          # Standard template variables
          - export APPNAME=$BITBUCKET_REPO_SLUG
          # We need to set version based on branch type
          - eval export THIS_VERSION=$VERSION
          - if [[ "$BITBUCKET_BRANCH" == "master" ]]; then
              eval export THIS_VERSION=$VERSION;
            elif [[ "$BITBUCKET_BRANCH" == "development" ]]; then
              eval export THIS_VERSION="development-$VERSION";
            else
              BRANCH_PREFIX="$(echo $BITBUCKET_BRANCH | cut -d '/' -f 1)";
              eval export THIS_VERSION="$BRANCH_PREFIX-$VERSION";
            fi
          - eval export THIS_SERVICE_PORT=$SERVICE_PORT
          - export IMAGE_NAME_VERSION=$DOCKER_HUB_IMAGE_REPO/$APPNAME:$THIS_VERSION
          - export IMAGE_NAME_LATEST=$DOCKER_HUB_IMAGE_REPO/$APPNAME:latest
          # build the Docker image (this will use the Dockerfile in the root of the repo)
          - docker build
            --build-arg BB_UN=$BITBUCKET_SERVICE_ACCOUNT_USERNAME
            --build-arg BB_PW=$BITBUCKET_SERVICE_ACCOUNT_PASSWORD
            --build-arg SERVICE_PORT=$THIS_SERVICE_PORT
            --build-arg APPNAME=$APPNAME
            -t $APPNAME .
          # authenticate with the Docker Hub registry
          - docker login --username $DOCKER_HUB_USERNAME --password $DOCKER_HUB_PASSWORD
          # push the new Docker image to the Docker registry
          - docker tag $APPNAME $IMAGE_NAME_VERSION
          - docker tag $APPNAME $IMAGE_NAME_LATEST
          - docker push $IMAGE_NAME_VERSION
          - docker push $IMAGE_NAME_LATEST
    - step: &deploy
        name: Deploy to dev
        image: google/cloud-sdk:alpine
        deployment: dev
        script:
          - export DEPLOY_SCRIPT='scripts/bb/bb_deploy.sh'
          - (umask 077; echo "$OPTII_DEPLOY_SSH_PRIV_KEY" |
            base64 -d > "$HOME/.ssh/id_rsa")
          # Need to pull deploy script from iac-resources repo
          - git archive --remote=git@bitbucket.org:optiisolutions/iac-resources.git
            $BB_DEPLOY_VERSION $DEPLOY_SCRIPT -o file.tar
            && tar -xvf file.tar
          - echo "Running $BB_DEPLOY_VERSION version of `basename $DEPLOY_SCRIPT`"
          # We need to set version based on branch type
          - eval export THIS_VERSION=$VERSION
          - if [[ "$BITBUCKET_BRANCH" == "master" ]]; then
              eval export THIS_VERSION=$VERSION;
            elif [[ "$BITBUCKET_BRANCH" == "development" ]]; then
              eval export THIS_VERSION="development-$VERSION";
            else
              BRANCH_PREFIX="$(echo $BITBUCKET_BRANCH | cut -d '/' -f 1)";
              eval export THIS_VERSION="$BRANCH_PREFIX-$VERSION";
            fi
          - echo $THIS_VERSION
          - bash $DEPLOY_SCRIPT --env-tag "$THIS_VERSION"
    - step: &deploy-gke
        name: Deploy to dev @ GKE
        image: google/cloud-sdk:latest # alpine need installing beta components and kubectl, maybe slim + install kubectl?
        deployment: dev
        script:
          - export APPNAME=$BITBUCKET_REPO_SLUG
          - (umask 077; echo "$OPTII_DEPLOY_SSH_PRIV_KEY" |
            base64 -d > "$HOME/.ssh/id_rsa")
            # download service-specific definition of k8s artifacts:
          - export DEPLOY_SCRIPT="scripts/gke/deploy.sh"
          - export DEPLOY_SCRIPT_FOLDER="scripts/gke/$BITBUCKET_REPO_SLUG"
          - export DEPLOY_SCRIPT_GENERIC_FOLDER="scripts/gke/_generic"
          - git archive --remote=git@bitbucket.org:optiisolutions/iac-resources.git
            $APP_DEPLOY_CONFIG_TAG "$DEPLOY_SCRIPT_FOLDER" -o files.tar
            && tar -xvf files.tar
          - git archive --remote=git@bitbucket.org:optiisolutions/iac-resources.git
            $APP_DEPLOY_CONFIG_TAG "$DEPLOY_SCRIPT_GENERIC_FOLDER" -o generic.tar
            && tar -xvf generic.tar
          - git archive --remote=git@bitbucket.org:optiisolutions/iac-resources.git
            $APP_DEPLOY_CONFIG_TAG "$DEPLOY_SCRIPT" -o script.tar
            && tar -xvf script.tar
          - echo "Running $APP_DEPLOY_CONFIG_TAG version of `basename $DEPLOY_SCRIPT`"
          # We need to set version based on branch type
          - eval export THIS_VERSION=$VERSION
          - if [[ "$BITBUCKET_BRANCH" == "master" ]]; then
              eval export THIS_VERSION=$VERSION;
            elif [[ "$BITBUCKET_BRANCH" == "development" ]]; then
              eval export THIS_VERSION="development-$VERSION";
            else
              BRANCH_PREFIX="$(echo $BITBUCKET_BRANCH | cut -d '/' -f 1)";
              eval export THIS_VERSION="$BRANCH_PREFIX-$VERSION";
            fi
          - echo $THIS_VERSION
          - eval export ENV_NAME="$APP_ENV_GKE"
          - if [["$ENV_NAME" == "production"]] ; then export ENV_NAME="prod"; fi
          - export PORT=80
          # setup service key file & creds
          - export GCP_SVC_ACC_JSON_LOCATION="$HOME/.ssh/sk.json"
          - (umask 077; echo "$GCP_SERVICE_KEY" |
            base64 -d > "$GCP_SVC_ACC_JSON_LOCATION")
          - export GOOGLE_APPLICATION_CREDENTIALS="$HOME/.gcp/sk.json"
          - export GCP_SSH_KEY_PRIVATE_LOCATION="$HOME/.ssh/google_compute_engine"
          - (umask 077; echo "$GCP_SERVICE_SSH_KEY_PRIVATE" |
            base64 -d > "$GCP_SSH_KEY_PRIVATE_LOCATION")
          - export GCP_SSH_KEY_PUBLIC_LOCATION="$HOME/.ssh/google_compute_engine.pub"
          - (umask 077; echo "$GCP_SERVICE_SSH_KEY_PUBLIC" |
            base64 -d > "$GCP_SSH_KEY_PUBLIC_LOCATION")
          # exec deployment and hope for the best! :)
          # --api-ver  - this isn't quite in use right now, however in future...
          - if [[ -z "${NUM_INSTANCES}" ]]; then export NUM_INSTANCES=1; fi
          - bash $DEPLOY_SCRIPT --image-tag "$THIS_VERSION" --app-name "$APPNAME" --env-name "$ENV_NAME" --int-port "$PORT" --ext-port "$PORT" --api-ver "v1" --replicas-num "$NUM_INSTANCES" --dh-user "$DOCKER_HUB_USERNAME" --dh-pass "$DOCKER_HUB_PASSWORD"
    - step: &unit-tests
        name: Run unit and integration tests
        image: golang:1.16.2
        caches:
          - pip
          - docker
        services:
          - docker
        script:
            # we will have some special env var to control if we want bypass tests
            # USE THIS WITH CAUTION AND ONLY SET ENV VAR ON DEV ENVIRONMENT (DEPLOYMENT) IN BBP!!!!!!!!!
            ##### SANITY CHECK :)
          - set -e
          - (umask 077; echo "$OPTII_DEPLOY_SSH_PRIV_KEY" |
            base64 -d > "$HOME/.ssh/id_rsa")
          - git config --global url."git@bitbucket.org:".insteadOf "https://bitbucket.org/"
          - go get -u github.com/jstemmer/go-junit-report
          - go get
          - mkdir ./test-reports
          - export TEST_LOG_FILE="./test.log" && export TEST_RESULT="./test-reports/results-unit.xml"
          - go test -tags=unit -v ./... 2>&1 > $TEST_LOG_FILE || true
          - cat $TEST_LOG_FILE | go-junit-report > $TEST_RESULT
          - if [ -f $TEST_LOG_FILE ]; then RES=$(sed -n '/FAIL/{p;q}' $TEST_LOG_FILE);
            if [[ ! -z $RES ]]; then echo "Unit test(s) failed!"; exit 1; fi; fi
          - chmod 0500 "ci/dependencies.sh"
          - ci/dependencies.sh
          - export PG_HOST='localhost' && export PG_USER='app' && export PG_PORT='5521' && export PGPASSWORD='app' && export PG_DATABASE='template_service'
          - docker-compose -f ./docker-compose.integration-test.yml up --detach
          - /bin/bash "ci/postgresql-test.sh"
            # start integration tests now
          - export TEST_RESULT="./test-reports/results-integration.xml"
          - go test -tags=integration -v ./... 2>&1 > $TEST_LOG_FILE || true
          - cat $TEST_LOG_FILE | go-junit-report > $TEST_RESULT
          - if [ -f $TEST_LOG_FILE ]; then RES=$(sed -n '/FAIL/{p;q}' $TEST_LOG_FILE);
            if [[ ! -z $RES ]]; then echo "Integration test(s) failed!"; exit 1; fi; fi
    - step: &integration-tests
        name: Integration tests
        script:
          - echo "Integration tests would be run or validated within this step in"
            "dev environment before moving on to test environment for further testing."
    - step: &integration-tests-new
        name: Integration tests
        caches:
          - pip
          - docker
        services:
          - docker
        script:
          - set -e
          - chmod 0500 "ci/dependencies.sh"
          - ci/dependencies.sh
          - export PG_HOST='localhost' && export PG_USER='app' && export PG_PORT='5521' && export PGPASSWORD='app'; && export PG_DATABASE='template_service'
          - docker-compose -f ./docker-compose.integration-test.yml up --detach
          - /bin/bash "ci/postgresql-test.sh"
          - export TEST_LOG_FILE="./test.log" && export TEST_RESULT="./test-reports/results-unit.xml"
          - go test -tags=integration -v ./... 2>&1 > $TEST_LOG_FILE || true
          - cat $TEST_LOG_FILE | go-junit-report > $TEST_RESULT
          - if [ -f $TEST_LOG_FILE ]; then RES=$(sed -n '/FAIL/{p;q}' $TEST_LOG_FILE);
            if [[ ! -z $RES ]]; then echo "Integration test(s) failed!"; exit 1; fi; fi

pipelines:
  default:
    - step:
        <<: *unit-tests

  branches:
    '{development,develop}':
      - step:
          <<: *unit-tests
      - step:
          <<: *build
#          trigger: manual  # Uncomment to make this a manual deployment.
      - step:
          <<: *deploy-gke
          name: Deploy to dev
          deployment: dev
          trigger: manual  # Uncomment to make this a manual deployment.
      - step:
          <<: *deploy-gke
          name: Deploy to test
          deployment: test
          trigger: manual  # Uncomment to make this a manual deployment.

    '{feature/*,hotfix/*,bugfix/*}':
      - step:
          <<: *unit-tests
      - step:
          <<: *build
          trigger: manual  # Uncomment to make this a manual deployment.
      - step:
          <<: *deploy-gke
          name: Deploy to dev
          deployment: dev
          trigger: manual  # Uncomment to make this a manual deployment.

    '{release/*}':
      - step:
          <<: *unit-tests
      - step:
          <<: *build
#          trigger: manual  # Uncomment to make this a manual deployment.
      - step:
          <<: *deploy-gke
          name: Deploy to test
          deployment: test
          trigger: manual  # Uncomment to make this a manual deployment.

    master:
      - step:
          <<: *unit-tests
      - step:
          <<: *build
          name: Build master
      - step:
          name:  Approved for Prod Environment.
          trigger: manual  # Uncomment to make this a manual deployment.
          script:
            - echo "This build has been approved and signed off for deployment to Production."
      - step:
          <<: *deploy
          name: Deploy to production
          deployment: production
          trigger: manual  # Uncomment to make this a manual deployment.
